1. 요구사항 확인
1) 소프트웨어 생명 주기
운용/유지보수 등의 과정을 각 단계별로 나눈 것

소프트웨어 개발 단계, 각 단계별 주요 활동, 산출물로 표현
소프트웨어 생명 주기 모형: 소프트웨어 생명 주기를 표현하는 형태
aka 소프트웨어 프로세스 모형, 소프트웨어 공학 패러다임
2) 소프트웨어 공학
소프트웨어 위기 극복 방안으로 연구된 학문

- 기본 원칙
현대적 기술
지속적 검증
기록 유지
3) 폭포수 모형
회귀X, 선형순차적
고전적 생명주기 모형 → 경험, 성공사례 많음
각 단계 끝에 산출물
타당성 검토 → 계획 → 요구 분석 → 설계 → 구현(코딩) → 시험(검사) → 유지보수
4) 나선형 모형
보헴
폭포수, 프로토타입의 장점 + 위험 분석 기능
나선을 따라 돌듯 여러번의 SW 개발과정 반복
계획 → 위험 분석 → 개발/검증 → 고객평가 (→ 계획 ...)
5) 애자일 모형
민첩한, 기민한

요구사항 변동에 대응하기 쉽도록 일정 주기 반복
고객 소통에 초점, 기업활동 전반적 사용
ex) 스크럼, XP, 칸반, Lean, 크리스탈, ASD, 기능 중심 개발(FDD)
- 4가지 핵심 가치
상호작용, 실행되는 SW, 고객 협업, 변화

프로세스, 도구 < 개인과 상호작용
문서 < 실행되는 SW
계약, 협상 < 고객과 협업
계획 < 변화
- 스크럼
팀 중심으로 개발 효율↑
self-organizing, cross-functional
> 스크럼 팀 구성
제품 책임자(PO, Project Owner)
이해 관계자 중 제품 이해도 높고 의사 결정할 사람 → 주로 개발 의뢰자, 사용자
요구사항 작성 주체
테스트 수행 → 요구사항 우선순위 갱신
스크럼 마스터(SM)
스크럼 팀 조언, 가이드(통제X)
일일 스크럼 회의 주관 → 진행사항 점검, 장애요소 처리
개발팀(DT)
위에 두 명 빼고 다. 개발자 + 디자이너 + 테스터
최대 7~8명
> 스크럼 개발 프로세스
제품 백로그(Product Backlog)
요구사항(User Story) 우선순위에 따라 나열
스프린트 계획 회의
백로그 중 이번 스프린트 작업 대상 단기 계획
스프린트
실제 개발(2~4주), 백로그 테스트 대상으로 속도 추정, 담당자 할당
일일 스크럼 회의
15분간 진행상황 점검, 서서 진행, 남은 작업 시간은 소멸차트에(Burn-down Chart)
스프린트 검토 회의
사용자가 포함된 참석자 앞에서 테스트
스프린트 회고
- XP
eXtreme Programming

요구사항에 대한 유연한 대처를 위해 고객 참여, 개발 과정 반복 극대화
목적: 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적 참여 → 빠른 개발
릴리즈 기간 짧게 반복 → 요구사항 반영 가시성
핵심 가치: 1) 의사소통 2) 단순성 3) 용기 4) 존중 5) 피드백
> 주요 실천 방법
짝 프로그래밍
공동 코드 소유(Collective Ownership)
TDD: 테스트 우선 작성, 테스트 자동화 도구
전체 팀: 구성원(고객 포함) 모두 역할, 책임 가짐
CI: 모듈 개발 → 지속적 통합
Design Improving/Refactoring
Small Release
6) 현행 시스템 파악
- 1단계: 시스템
시스템 구성 파악: 기간 업무(주요 업무), 지원 업무 구분
시스템 기능 파악: 주요, 하부, 세부 기능으로 계층화
시스템 인터페이스 파악: 단위 업무 시스템 간 데이터 종류/형식/프로토콜/연계유형/주기
- 2단계: SW
아키텍처 구성 파악: 최상위 수준에서 계층별로 아키텍처 구성도 작성
소프트웨어 구성 파악: 제품명, 용도, 라이센스 등
- 3단계: HW
하드웨어 구성 파악: 서버 사양, 수, 이중화 여부
네트워크 구성 파악: 네트워크 구성도(서버 위치, 연결 등)
7) 운영체제(OS)
컴퓨터 시스템 자원 관리, 유저의 효율적/편리한 사용 환경 제공 SW
사용자 - 하드웨어 간 인터페이스로 동작하는 시스템 SW → 다른 응용프로그램 환경 제공
OS관련 요구사항 식별 시 고려사항: 1) 가용성 2) 성능 3) 기술지원 4) 주변 기기 5) 구축 비용
8) 데이터베이스 관리시스템(DBMS)
사용자-DB 간(유저 요구에 따라) 정보 생성, DB 관리 SW
기존 파일 시스템이 갖는 데이터 종속성/중복성 문제 해결 → 모든 응용 프로그램이 DB 공용
DB 구성, 접근 방법, 유지관리 책임짐
DB 요구사항 식별 시 고려사항: 1) 가용성 2) 성능 3) 기술 지원 4) 상호호환성 5) 구축 비용
9) 웹 애플리케이션 서버(WAS)
동적인 콘텐츠 처리를 위해 사용되는 미들웨어 cf) WS
데이터 접근, 세션 관리, 트랜잭션 관리 라이브러리 제공
주로 DB와 연동해서 사용
톰캣, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere ...
10) 요구사항
- 요구사항 정의
서비스 설명, 정상 운영을 위한 제약 조건

> 기능 요구사항
입출력 무엇 포함, 시스템이 무엇을 저장하고 연산을 수행할지
시스템이 반드시 수행해야 하는 기능, 사용자가 원하는 기능
> 비기능 요구사항
시스템 장비 구성: HW, SW, 네트워크 등
성능: 처리 속도, 시간, 양, 동/정적 사용량, 가용성
인터페이스: 시스템/사용자 인터페이스 요구사항
정보 교환 시 사용되는 프로토콜과의 연계도 포함하여 기술
데이터: 초기 자료, 변환, 보안 등
테스트: 장비 성능, 정상적 운영 여부
보안
품질
제약 사항: 기술, 표준, 업무, 법/제도
프로젝트 관리: 수행 관리 방법
프로젝트 지원: 수행 지원
- 요구사항 개발 프로세스
도출(Eliciation) → 분석(analysis) → 명세(specification) → 확인(validation)

도출: 요구사항 수집(인터뷰, 설문, 브레인스토밍, 프로토타이핑, 유스케이스...)
분석: 모호한 부분 필터링 → 자료흐름도(DFD), 자료사전(DD)
명세: 문서화
확인(검증)
- 요구사항 명세 기법
> 정형 명세 기법
수학적 기호, 정형화된 표기법
특징: 간결한 표현, 작성자 독립적 결과(완전성 검증 가능), 표기법 어려움
VDM, Z, Petri-net, CSP
> 비정형 명세 기법
상태, 기능, 객체 중심 → 자연어, 다이어그램 작성
특징: 자연어라 일관성↓, 의사소통 용이
FSM, Decision Table, ER 모델링, State Chart(SADT)
- 요구사항 분석
유저 요구사항 이해, 타당성 조사 → 비용, 일정 제약
목표, 해결방법 결정
도구: UML(Unified Modeling Language), 자료흐름도(DFD), 자료 사전(DD), 소단위 명세서, ERD(개체 관계도), 상태 전이도(STD), 제어 명세서
> 자료 흐름도(Data Flow Diagram)
자료 흐름, 변환, 기능을 도형으로 기술
aka 자료 흐름 그래프, 버블 차트

기본 기호

프로세스(process): 자료 변환 시스템의 한 부분 (처리, 기능, 변환, 버블)
자료 흐름(data flow): 자료 이동, 연관관계
자료 저장소(data store): 파일, DD 등
단말(terminator): 시스템과 교신하는 외부 개체
> 자료 사전
자료 흐름도에 있는 자료를 더 정확히 정의 (=메타 데이터)

=: 정의
+: and
(): 생략
[|]: 선택(or)
{}: 반복
**: 주석
11) 요구사항 분석을 위한 CASE(자동화 도구)
SADT
Structured Analysis & Design Technique
SoftTech사, 시스템 정의/요구사항 분석, 설계, popular
SREM
Software Requirement Engineering Methodology
RSL/REVS 사용
RSL: 요구사항 기술 언어
REUS: RSL 분석해서 명세서 만듦
TRW사, 우주국방 시스템 그룹 요구사항 목적으로 개발
PSL/PSA: 미시간 대학
TAGS: 개발주기 전과정에서 이용 가능한 통합 자동화 도구
12) HIPO
Hierarchy Input Process Output

시스템 분석/설계/문서화에 사용되는 기법
시스템 실행 과정인 입력-처리-출력 기능을 나타냄

- 특징
기본 시스템 모델: 입력-처리-출력
하향식 소프트웨어 개발 문서화 도구
체계적 문서관리 가능
기호, 도표 사용 → 가독성, 이해↑
기능/자료 의존 단계 동시에 표현
변경, 유지보수 용이
- HIPO Chart
시스템을 여러개 모듈로 분할 → 이들간의 인터페이스를 계층 구조로 표현

> 종류
가시적 도표(도식 목차): 시스템 전체 기능, 흐름을 Tree 구조로
총체적 도표(총괄 도표, 개요 도포): 프로그램 구성 기능 (입-처-출 overall)
세부적 도표(상세 도포): detail
13) UML
Unified Modeling Language
시스템 개발 과정의 의사소통을 위해 만든, 대표적인 객체지향 모델링 언어

Rumbaugh(OMT), Booch, Jacobson의 객체지향 방법론의 장점 통합
OMG(객체 기술에 관한 국제 표준화 기구)에서 표준으로 지정
6개의 구조 다이어그램과 7개의 행위 다이어그램
각 다이어그램은 사물간 관계를 용도에 맞게 표현
구성요소: 사물(things), 관계, 다이어그램
- 관계(Relationship)
연관(Association)
집합(Aggregation): 2개 이상의 사물이 서로 포함
포함(Composition): 특수한 집합, 포함하는 사물의 변화가 포함되는 사물에게 영향
일반화(Generalization): A가 B보다 더 일반적인지, 구체적인지
의존(Dependency): 필요한 만큼만 연관 유지(오퍼레이션 매개변수)
실체화(Realization): 행위, 인터페이스로 서로 그룹화 할 수 있는 관계
- 다이어그램(Diagram)
> 개념
사물과 관계를 도형으로 표현

시스템을 가시화한 뷰 제공 → 의사소통
정적 모델링 = 구조적 다이어그램
동적 모델링 = 행위 다이어그램
> 구조적 다이어그램
클래스 다이어그램: 클래스 간 관계, 시스템 구조 파악, 문제점 도출 가능
객체 다이어그램: 인스턴스, 럼바우 객체모델링에서 사용
컴포넌트 다이어그램: 컴포넌트간 관계/인터페이스, 구현단계에서 사용
배치 다이어그램: Deployment, 노드와 의사소통 경로, 물리적 요소의 위치
복합체 구조 다이어그램: 클래스, 컴포넌트가 복합 구조를 갖는 경우 그 내부
패키지 다이어그램: 유스케이스, 클래스 등 모델 요소를 그룹화한 패키지 관계
> 행위 다이어그램
유스케이스 다이어그램: 유저 요구 분석, 사용자/사용 사례로 구성, 사례간 관계로 이루어짐
순차 다이어그램: 상호작용하는 시스템/객체간 주고받는 메시지
커뮤니케이션 다이어그램: 메시지 + 객체 간 연관
상태 다이어그램: 한 객체가 상호작용에 따라 어떻게 변화하는지 (럼바우 객체지향 분석기법의 동적 모델링)
활동 다이어그램: 로직 처리 흐름
상호작용 개요 다이어그램: 상호작용 다이어그램 간 제어흐름
타이밍 다이어그램: 상태변화와 시간 제약을 표현
> 유스케이스 다이어그램 (행위)
사용자 관점에서 사용자가 할 수 있는 것 표현

구성요소

시스템, 시스템 범위: 시스템 내부의 유스케이스를 사각형으로 묶어 외부 시스템과 구분
액터: 시스템과 상호작용하는 대상들
주 액터: 이득을 얻는 대상 ex) 사람
부 액터: 주액터의 목적 달성을 위해 서비스를 제공하는 외부 시스템 ex) 조직, 기관
유스케이스: 제공 기능
관계: 액-유, 유-유 사이에서 나타남 → 연관, 포함, 확장, 일반화
> 클래스 다이어그램(구조적)
클래스, 속성과 오퍼레이션, 제약조건, 클래스간 관계 표현

구성요소

클래스: 이름, 속성, 오퍼레이션 표기
제약조건
관계: 연관, 집합, 포함, 일반화, 의존
> 순차 다이어그램 (행위)
시스템-객체가 메시지를 주고받으며 상호작용하는 과정을 그림으로

구성요소

액터
객체: 메시지 주고받는 주체
생명선(lifeline): 객체가 메모리에 존재하는 구간(점선)
실행상자(active box): 객체가 메시지를 주고받으며 구동중
메시지
> 스테레오타입
UML 기본 기능 외 추가 기능 표현
<< >> → 길러멧

<<include>>: 포함
<<extend>>: 확장
<<interface>>
<<exception>>
<<constructor>>
2. 화면 설계
1) 사용자 인터페이스의 특징
사용자 만족도에 가장 큰 영향 → 변경 잦음
유저 편리성, 가독성 높여서 작업시간 단축, 업무 이해도 ↑
최소 노력으로 결과 내게끔
사용자 중심 설계, 상호작용
수행결과 오류 줄이기
정보제공자, 공급자간 매개 역할
설계 시 소프트웨어 아키텍처 숙지 필요
2) UI 구분
CLI(Command Line Interface): 명령, 출력, 테스트
GUI
NUI(Natural): 유저의 말, 행동
VUI(Voice): 음성
OUI(Organic): 모든 사물-사용자간 상호작용, HW → IoT, VR, 증강현실, 혼합현실
3) 기본 원칙
직관성
유효성: 사용자의 목적을 달성
학습성: 러닝커브 낮추기
유연성: 요구사항 최대한 수용 및 실수 최소화
4) 설계 지침
사용자 중심
사용성: 학습 쉽고 효율적이게 → 가장 우선적 고려사항
심미성
오류 발생 해결: 사용자의 오류 인지 쉽도록
5) 기능
입력 검증, 에러 처리 및 메시지 표시, 도움/프롬프트 제공

6) 설계 도구
- 와이어프레임
기획 초기 개략적인 레이아웃
손그림, ppt, 키노트, 스케치, 일러스트, 포토샵

- 목업
와이어프레임보다 실제 화면에 가깝지만 정적인 모형(구현 X)
파워 목업, 발사믹 목업

- 스토리보드
와이어프레임 + 콘텐츠 설명 + 페이지간 이동 흐름
디자이너, 개발자의 초종 참고본 → 정책, 프로세스, 콘텐츠 구성, 와이어프레임, 기능정의
ppt, 키노트, 스케치, Axure

- 프로토타입
와이어프레임/스토리보드 + 인터렉션 → 테스트 가능, 동적 모형
사용성 테스트, 작업자간 서비스 이해를 위해 작성

- 유스케이스
사용자 측면의 요구사항, 사용자 목표 달성을 위해 수행할 내용
프로젝트 초기에 기능적 요구 결정, 결과 문서화 가능

7) 품질 요구 사항
사용자 요구사항 충족으로 확립

ISO/IEC 9126: 국제 표준(SW 품질 표준 지침)
ISO/IEC 25010: 9126 개정, 제품에 대한 국제 표준
ISO/IEC 12119: 9126 + 테스트
ISO/IEC 14598: 개발자, 구매자, 평가자 별 수행활동 규정
- 요소
기능성(functionality): 요구사항 만족 여부
신뢰성(reliability): 요구된 기능을 일관적으로 오류 없이 수행
사용성(usability): 사용자가 정확히 이해하고 사용하는지, 또 쓰고 싶은지
효율성(efficiency): 빨리 처리
유지보수성(maintainablity): 분석성, 변경성, 안정성, 시험성
이식성(portablity): 다른 환경에서 적용 가능한지
8) UI 요소
체크박스: 다중다선택
라디오 버튼: 다중일
텍스트박스
콤보박스: 지정된 목록 + 새 입력
목록 상자: 입력X
3. 애플리케이션 설계
1) 상위 설계, 하위 설계
상위설계	하위설계
아키텍서 설계, 예비 설계	모듈 설계, 상세 설계
시스템의 전체적 구조	시스템 내부 구조, 행위
구조, DB, 인터페이스	컴포넌트, 자료구조, 알고리즘
2) 소프트웨어 아키텍처 설계
- 기본 원리
모듈화: 성능 향상, 수정, 재사용, 유지관리
추상화: 전체적 설계 → 세분화/구체화 → 추상화
단계적 분해: 하향식 설계 전략 (상위 중요 개념 → 하위개념)
정보 은닉: 다른 모듈 접근, 변경X
- 품질 속성
품질 평가 요소를 세 측면으로 나누어 구체화시킨 것

시스템 측면: 성능, 보안, 가능성, 기능성, 사용성, 변경 용이성 ...
비즈니스 측면: 시장적시성, 비용/혜택, 예상 시스템 수명
아키텍처 측면: 개념적 무결성, 정확성, 완결성, ...
- 설계 과정
설계 목표 설정
시스템 타입 결정: 시스템/서브시스템 타입, 아키텍처 패턴...
아키텍처 패턴 적용: 시스템 표준 아키텍처 설계
서브 시스템 구체화
검토
3) 협약(Contract)에 의한 설계
컴포넌트 설계 시 클래스에 대한 여러 가정을 공유할 수 있도록 명세

선행조건: 오퍼레이션 호출 전 true여야 할 조건
결과조건: 오퍼레이션 수행 후 만족해야 할 조건
불변조건: 오퍼레이션 실행동안 항상 만족되어야 할 조건
4) 아키텍처 패턴
- 파이프 필터 패턴
데이터스트림 각 단계를 필터로 캡슐화, 파이프를 통해 전송

필터 재사용성 ↑, 추가 쉬움 → 확장성
필터 컴포넌트 재배치하여 다양한 파이프라인 구축 가능
데이터 변환, 버퍼링, 동기화에 사용
ex) UNIX Shell
Source --Pipe1--> Filter1 --Pipe2--> Filter2 --Pipe3--> Sink
- MVC
서브 시스템을 3개로 구조화하는 패턴

Model: 서브시스템 핵심 기능 + 데이터 보관
View
Controller: 사용자 입력값 처리를 위해 모델에게 명령
mvc

- 기타 패턴
마스터-슬레이브 패턴
마스터 컴포넌트가 슬레이브한테 작업 분할해주면 슬레이브가 돌려줌
장애 허용 시스템, 병렬 컴퓨팅 시스템
브로커 패턴
브로커가 요청에 맞는 컴포넌트 찾아서 유저와 연결
분산 환경 시스템
피어 투 피어 패턴
피어가 클라이언트가 될 수도 있고 서버가 될 수도
이벤트-버스 패턴
publish-subscribe
블랙보드 패턴
모든 컴포넌트가 공유데이터, 블랙보드 컴포넌트에 접근 가능
음성인식, 차량 식별, 신호해석
인터프리터 패턴
코드 각 라인 수행방법 지정 → 기호마다 클래스를 갖도록 구성
5) 객체지향
- 객체
> 개념
소프트웨어 모듈. 데이터 + 함수

데이터
객체가 가진 정보 → 속성, 상태, 분류
aka 속성, 상태, 변수, 상수, 자료구조
함수
객체가 수행하는 기능 → 데이터 처리 알고리즘
aka 메소드, 서비스, 동작(Operation), 연산
> 특성
독립적으로 식별 가능한 이름
상태(state)는 시간에 따라 변함
객체간 상호 연관성에 의한 관계
행위: 객체가 반응할 수 있는 메시지의 집합 → 객체는 행위의 특징을 나타낼 수 있다
일정한 기억장소를 가짐
메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행

- 클래스
공통된 속성, 연산을 갖는 객체의 집합 / 객체의 일반적인 타입

객체의 속성, 연산을 정의하는 틀
객체지향 프로그램에서 데이터를 추상화하는 단위
인스턴스, 인스턴스화
- 캡슐화(Encapsulation)
데이터와 함수를 하나로 묶는 것

캡슐화된 객체는 인터페이스를 제외한 디테일이 은폐(정보은닉) → 외부 접근 제한 → 외부 변경에 의한 파급↓
재사용 용이
메시지 주고 받을 때 상대 객체의 디테일은 몰라도 됨 → simple interface, 결합도 ↓
- 상속(Inheritance)
부모클래스의 모든 속성/연산을 자식클래스가 물려받음

자신만의 속성/연산 추가 가능
- 다형성
메시지에 의해 객체가 연산 수행 시, 각 객체가 고유한 방법으로 응답할 수 있는 능력

객체는 동일한 메소드명으로 같은 응답 가능
한 함수/연산자로 둘 이상의 다른 클래스의 인스턴스가 같은 인스턴스처럼 수행할 수 있게
+: 숫자 클래스 == 덧셈, 문자열 클래스 == 결합
오버로딩: 같은 이름, 다른 파라미터 타입/개수
오버라이딩: 상위 클래스 메소드 재정의
- 연관성
둘 이상의 객체가 상호참조하는 관계

종류

is member of(연관화, association): 상호 관련
is instance of(분류화, classification): 동일한 형의 특성 모으기
is part of(집단화, aggregation): 객체 모아 하나의 상위 객체
is a (특수화, 상세화, specification): 상위 구체화 → 하위 객체
2) 객체지향 분석 및 설계
- 객체지향 분석의 방법론
럼바우: 가장 일반적으로 사용 / 객체, 동적, 기능 모델로 분석
부치: 미시, 거시 개발 프로세스
제이콥슨: 유스케이스
Coad/Yourdon: ERD
Wirfs/Brock: 분석, 설계 구분 X, 명세서 중심
- 럼바우의 분석 기법
SW 구성요소를 그래픽 표기법으로 모델링
객체 모델링 표기법(OMT, Object-Modeling Technique)

순서: 객체 모델링 → 동적 모델링 → 기능 모델링
객체 모델링: 정보 모델링, 객체를 ERD로
동적 모델링: 상태다이어그램으로 시간에 따른 객체 행위 모델링
기능 모델링: 자료흐름도(DFD)로 자료 흐름/처리과정 모델링
- 객체지향 설계 원칙(SOLID)
단일 책임(SRP, Single Responsibility Principle)
개방 폐쇄(OCP, Open-Closed P): 기존 코드 변경 없이 기능 추가 가능해야
리스코프 치환(LSP, Liskov Substitution): 자식 클래스는 최소한 부모가 할 수 있는 일은 할 줄 알아야 함
인터페이스 분리(ISP, Interface Segregation): 사용X 인터페이스와 관계, 영향X
의존역전(DIP, Dependency Inversion): 추상성 높은 클래스와 의존
3) 모듈
- 결합도(Coupling)
모듈 간 상호의존 하는 정도, 모듈간 연관관계
약할수록 품질이 높고, 강할수록 구현, 유지보수성 낮아짐

> 종류(약한 순)
자료 결합도: 인터페이스가 자료 요소로만 구성
스탬프 결합도: 자료구조 요소로만 구성
제어 결합도: 제어신호, 제어요소(function, switch, tag, flag)
외부 결합도: 한 모듈의 데이터(변수)를 다른 모듈에서 참조
공통(공유) 결합도: 공통 데이터 영역을 여러 모듈이 사용
내용 결합도: 다른 모듈의 기능, 자료를 직접 참조
- 응집도(Cohesion)
모듈이 독립된 정도 → 강할수록 품질 좋음

> 종류 (강한 순)
기능적 응집도: 모든 기능이 단일 문제 연관
순차적 응집도: A모듈의 출력이 B모듈의 입력
교환(통신)적: 동일 입출력으로 서로 다른 기능
절차적: 모듈이 다수 기능 가질 때, 구성요소가 그 기능을 순차적 수행
시간적: 특정 시간에 처리되는 몇 기능을 묶은 하나의 모듈
논리적: 유사 성격/형태의 요소로 모듈 구성
우연적: 관련 없는 요소
- 팬인/팬아웃
팬인(제어, 호출하는 모듈의 수), 팬아웃(호출되는 모듈의 수)

fan-in-out

- N-S 차트
Nassi-Scheneiderman Chart

논리 기술 중점, 도형으로 표현
박스 다이어그램, Chapin Chart

제어 논리 구조 표현: 연속, 선택/다중석택, 반복 등
GOTO, 화살표 사용 X
복합 조건의 처리, 선택, 반복 구조를 시각적으로 명확히 표현 가능
단일 입구, 단일 출구
이해하기 쉽고 코드 변환 용이 / 작성 어렵고 임의적 제어선이 없음, 총체적 구조나 인터페이스 표현 난해
4) 공통 모듈
- 개념
자주 쓰는 계산식, 매번 필요한 사용자 인증 등
설계 과정에서 공통부분 식별, 명세 작성 필요

> 명세 기법
정확성, 명확성, 완전성, 일관성, 추적성

- 재사용
이미 개발된 기능으로 새 시스템, 기능 개발 재구성

사용법 공개: 누구나 쓰기 쉽도록
결합도는 낮게, 응집도는 높게
> 규모에 따른 분류
함수, 객체: 냅다 갖다씀
컴포넌트
독립적 기능을 수행하는 코드 기반으로 작성된 모듈
컴포넌트 수정 없이 인터페이스 사용해 통신
애플리케이션: 공통 기능 애플리케이션 공유
- 설계 방안
결합도는 낮게 응집도는 높게
모듈의 제어영역 안에서 영향영역 유지
복잡도, 중복성 낮게, 일관성 유지
모듈의 기능은 예층 가능해야하고, 지나치게 제한적이면 안됨
유지보수성
시스템 전반적인 기능/구조를 이해하기 쉬운 크기로 분리
모듈간 계층관계 자료 필요
5) 코드
- 개요
자료 처리 과정, 자료 추출을 용이하게 하려고 쓰는 기호

정보를 신속, 명확, 정확하게 전달할 수 있게
주민등록번호, 학번, 전화번호
주요 기능: 식별, 분류, 배열(의미 부여해서 나열 가능), 표준화(다양한 데이터를 기준에 맞게 표현), 간소화

- 종류
순차코드: auto_increment
블록코드: 공통성 블록으로 묶고 그 안에서 auto_increment
10진 코드: 도서관
그룹 분류 코드: 1-01-001 == 총무부
연상코드: TV-40
표의 숫자 코드: 120-720-1500
합성코드: Ke-711 대한항공 711
6) 디자인 패턴
- 개요
설계 시 참조할만한 전형적인 해결방식

문제/배경, 사례, 샘플코드
Don't reinvent the wheel
GoF의 디자인 패턴: 생성(5), 구조(7), 행위(11) → 총 23
- 장단점
범용성 높고 구조 파악 용이
객체지향 설계, 생산력 증대
이미 검증됨 → 개발 시간, 비용 단축
초기 투자비용 높음
개발자간 의사소통 용이
설계 변경 요청 대처 가능
객체지향 아니면 곤란
- 생성 패턴(Creational Pattern)
객체의 생성, 참조과정 캡슐화 → 객체 생성/변경 시 영향 낮춤 → 프로그램 유연성 증대

> 추상팩토리
구체적 클래스가 아니라 인터페이스를 통해 연관객체 그룹으로 생성
서브클래스 통째로 교체 가능
> 빌더
생성, 표현 분리

> 팩토리 메소드
객체 생성을 서브클래스로 분리
상위 클래스에선 인터페이스만 정의
가상생성자 패턴
> 프로토타입
원본 객체 복제
일반적 방법으로 생성, 비용이 큰 경우 사용
> 싱글톤
생성된 객체를 어디서든 참조 가능, 여러 프로세스 동시 참조 불가
메모리 낭비 X. 하나의 인스턴스 보장
- 구조 패턴
클래스 조합해서 더 큰 구조로

> 어댑터
호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있게
기존 클래스 쓰고 싶은데 인터페이스가 다를 때
> 브릿지
추상층 분리, 독립적 확장
기능과 구현을 두 개의 별도 클래스로
> 컴포지트
여러 객체를 가진 복합객체와 단일 객체를 구분없이 다루고자 할 때
객체들을 트리구조로 구성 → 복합 객체 안에 복합객체
> 데코레이터
객체간 결합으로 기능 확장
부가 기능 추가를 위해 다른 객체 덧붙이기
> 퍼싸드
복잡한 서브클래스를 피해 더 상위에 인터페이스 구현, 서브클래스들 간편하게 사용
서브 클래스 간 통합 인터페이스로서의 Wrapper 객체 필요
> 플라이웨이트
인스턴스를 가능한 한 공유해서 메모리 절약
다수의 유사객체 필요시 유용
> 프록시
접근 어려운 객체와 얘한테 연결하려는 객체 간 인터페이스
네트워크 연결, 메모리 대용량 객체로의 접근 시
- 행위 패턴
객체간 상호작용, 책임 분배 방법 정의
하나의 객체로 수행할 수 없는 작업을 다른 객체로 분배하여 결합도 낮춤

> 책임 연쇄(Chain of Responsibility)
요청처리 객체가 둘 이상일 때, 한 객체가 처리 못하면 다음 객체 줌
객체간 고리로 연결 - 요청 해결까지 고리 따라감
> 커맨드
요청을 객체로 캡슐화 → 재이용, 취소 가능하도록 정보 저장/로그 남김
요청에 사용되는 각종 명령어를 추상/구체 클래스로 분리하여 단순화
> 인터프리터
언어에 문법 표현을 정의
SQL, 통신 프로토콜
> 반복자
자료구조와 같이 접근이 잦은 객체에 동일한 인터페이스 사용
내부 노출 없이 순차적 접근 가능
> 중재자
객체간 복잡한 상호작용을 캡슐화하여 객체로 정의
객체간 의존성 줄여 결합도 감소
> 메멘토
특정 시점에서의 객체 내부를 객체화 → ctrl z
> 옵서버
객체 - 상속된 다른 객체 간 publish-subscribe
> 상태
객체 상태에 따라 동일 동작 다르게 처리할 때
객체 상태를 캡슐화, 이를 참조
> 전략
유사 알고리즘 개별적 캡슐화 → 상호 교환 가능하도록 정의
클라이언트는 독립적으로 원하는 알고리즘 선택 가능, 클라이언트에 영향 없이 알고리즘 변경 가능
> 템플릿 메소드
상위 클래스에서 골격을, 하위 클래스에서 구체화
유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의 → 코드 양 줄이고 유지보수성 높임
> 방문자
각 클래스의 데이터 구조에서 처리기능을 분리하여 별도의 클래스로
분리된 처리 기능은 각 클래스를 방문하여 수행
4. 인터페이스 설계
1) 시스템 인터페이스 요구사항
- 검증 방법
> 요구사항 검토(Requirements Review)
명세서 오류, 결함을 담당자들이 수작업으로 분석

동료 검토: 작성자가 발표하면 동료가 들어보면서 결함 찾기
워크스루: 명세서 배포 후 검토 회의
인스펙션: 검토 전문가들이 확인
> 프로토타이핑
견본품(prototype)을 만들어 최종 결과물 예측

> 테스트 설계
테스트 케이스 생성

> CASE 도구 활용
일관성 분석을 통해 확인

2) 시스템 연계 기술
DB Link: DB가 제공하는 DB Link 객체를 이용
API/Open API: 송신시스템 DB에서 데이터 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
연계 솔루션: EAI 서버와 송수신 시스템의 클라이언트 이용
Socket: 서버는 소켓 생성, 포트 할당 → 클라이언트 요청 시 연결하여 통신하는 네트워크 기술
Web Service: WSDL, UDDI, SOAP 프로토콜
3) 연계 매커니즘 구성 요소
송신 시스템
연계 프로그램에서 온 데이터를 형식에 맞게 인터페이스 테이블, 파일 등으로 변환 후 송신하는 시스템
수신 시스템
수신한 인터페이스 테이블, 파일을 연계 프로그램에서 처리할 수 있는 형식으로 변환
연계 서버
송/수신 시스템 사이에서 현황 모니터링
4) 미들웨어
운영체제와 응용 프로그램, 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 SW

DB
DB 클라이언트-원격DB 연결용 미들웨어
2-Tier 아키텍처: DB를 사용하여 시스템 구축
RPC
Remote Procedure Call, 원격 프로시저 호출
원격 프로시저를 로컬처럼 호출
MOM
Message Oriented Middleware, 메시지 지향 미들웨어
비동기형 메시지 전달 방식
온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 사용
TP-Monitor
Transaction Processing Monitor, 트랜잭션 처리 모니터
항공기, 철도 예약 업무 등 온라인 트랜잭션 업무에서 트랜잭션 처리, 감시 미들웨어
사용자가 증가해도 빠른 응답 속도를 유지해야 하는 업무
ORB
Object Request Broker, 객체 요청 브로커
객체 지향, 코바(CORBA) 표준 스펙 구현
최근에는 TP-Monitor의 장점인 트랜잭션 처리, 모니터링 추가 구현 제품도 있음
WAS
Web Application Server
동적인 콘텐츠 처리를 위한 미들웨어
클라이언트-서버 환겨보다는 웹 환경을 구현하기 위한 미들웨어

1. 데이터 입출력 구현
1) 자료 구조
선형 구조: 배열, 선형 리스트(연속/연결 리스트), 스택, 큐, 데크
비선형 구조: 트리, 그래프
2) 선형 구조
- 선형 리스트
> 연속 리스트
연속되는 기억장소(≒배열)
기억장소 이용 효율 가장 좋음 (밀도 1)
데이터 중간 삽입 시 빈 공간 필요, 삽입/삭제 시 자료 이동 필요
> 연결 리스트
자료를 임의의 기억공간에 기억, 노드로 연결 → 삽입/삭제 용이
기억 공간이 연속적으로 놓여있지 않아도 저장 가능
순차 리스트 대비 기억 공간 효율 ↓
접근 속도 느림: 포인터 찾아야함
중간 노드 끊어지면 다음 노드 찾기 어려움
- 스택
한쪽 끝으로만 삽입, 삭제 (LIFO)
스택 full인 상태에서 데이터 삽입 → 오버플로
빈 스택에서 데이터 삭제 → 언더플로
> 응용 분야
함수 호출 순서 제어, 인터럽트 처리, 수식 계산, 컴파일러의 언어 번역, 복귀 주소 저장

- 큐
한 쪽에서 삽입, 다른 쪽에서 삭제 (FIFO)
시작과 끝을 표시하는 두 개의 포인터
3) 비선형 구조
- 그래프
> 방향/무방향 그래프의 최대 간선 수
정점 n개

무방향 그래프: n(n-1)/2
방향 그래프: n(n-1)
graph

- 트리
> 정의
정점(노드)과 선분(브랜치)를 이용하여 사이클을 이루지 않도록 구성한 특수한 그래프

> 관련 용어
노드: 자료 항목 + 가지(branch)
근 노드(Root Node): 최상위 노드
디그리(차수): 각 노드에서 뻗어나온 가지의 수
단말 노드(Terminal Node): 잎 노드(Leaf Node), 자식이 하나도 없는 노드, 디그리 0
자식 노드 / 부모 노드 / 형제 노드
트리의 디그리: 디그리 최대값
> 운행법
Preorder 운행: Root → Left → Right
Inorder 운행: Left → Root → Right
Postorder 운행: Left → Right → Root
node

Preorder
A13 → AB2E3 → ABDHIE3 → ABDHIECFG
Inorder
1A3 → 2BEA3 → HDIBEA3 → HDIBEAFCG
Postorder
13A → 2EB3A → HIDEB3A → HIDEBFGCA
4) 수식의 표기법
- 표기법
전위 표기법(Prefix): +AB
중위 표기법(InFix): A+B
후위 표기법(PostFix): AB+
- Infix → PreFix, PostFix
X = A / B * (C + D) + E

PreFix
=X+*/AB+CDE
PostFix
XAB/CD+*E+=
- PostFix → Infix
A B C - / D E F + * +

A / (B - C) + D * (E + F)

- PreFix → Infix
+ / A - B C * D + E F

A / (B - C) + D * (E + F)

5) 정렬
- 삽입 정렬
key 요소를 기존의 정렬된 자료 사이의 올바른 자리를 찾아 삽입
key 요소는 두번째 요소부터 시작

8 5 6 2 4
5 8 | 6 2 4
5 6 8 | 2 4
2 5 6 8 | 4
2 4 5 6 8
- 선택 정렬
해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
최소값 찾기 → 맨 앞 값과 교체 → 계속 반복

8 5 6 2 4
2 8 5 6 4
2 4 8 5 6
2 4 5 8 6
2 4 5 6 8
- 버블 정렬
인접 요소끼리 비교해서 크면 한 칸씩 뒤로 보냄 (매번 비교 + 교환)

8 5 6 2 4
5 8 6 2 4 → 5 6 8 2 4 → 5 6 2 8 4 → 5 6 2 4 8
5 2 6 4 8 → 5 2 4 6 8
2 5 4 6 8 → 2 4 5 6 8
- 퀵 정렬
피벗 기준 작으면 왼쪽, 크면 오른 쪽으로
분할과 정복
평균: O(n log n) / 최악: O(n^2)



- 힙 정렬
완전 이진 트리(Complete Binary Tree) 사용
구성된 전이진 트리를 Heap Tree로 변환 후 정렬
O(n log n)

cf) 완전 이진 트리
부모 자식 간 특정 조건 만족, 자식 노드 최대2, 모든 레벨 노드 full

- 합병 정렬
이미 정렬된 두 개의 파일을 하나로 합병하는 정렬
O(n log n)

6) 이진 검색
전체 파일을 두 개의 서브 파일로 분리하며 key 레코드 검색하는 방식

순서화된 파일만 가능
대상 key 값을 중간 레코드 key 값과 비교하며 검색
비교 거듭 할때마다 검색 대상이 절반으로 줄어듦
중간 레코드 번호 = (first + last ) / 2
7) 해싱 함수
1) 제산법(Division)

홈 주소: 해시테이블의 크기보다 큰 수 중 가장 작은 소수(Prime, Q)로 나눈 나머지
h(K) = K mod Q
2) 제곱법(Mid-Square)

홈 주소: K^2의 중간 부분 값
3) 폴딩법(Folding)

홈 주소: K를 여러 부분으로 나눈 후 각 부분의 합이나 XOR(배타적 논리합)한 값
4) 기수 변환법(Radix)

키 숫자를 다른 진수로 변환 후 주소 범위에 맞게 조정
5) 대수적 코딩법

홈 주소: 키 값 각 자리의 비트수를 다항식의 계수로 간주, 이를 해시표의 크기로 정의된 다항식으로 나누어 얻은 나머지 다항식의 계수
6) 숫자 분석법

키 값 숫자의 분포 분석 → 비교적 고른 자리를 택해서 홈주소
7) 무작위법: 난수

8) DB
- DBMS
DB 관리, 요구에 따른 정보 생성 SW

필수 기능
정의 기능: 데이터 타입, 구조, 제약 조건 등을 명시 가능
조작 기능: CRUD 인터페이스 제공
제어 기능: CUD의 정확한 수행으로 데이터의 무결성 유지
장점
데이터의 논리적, 물리적 독립성 보장
중복 피해서 기억 공간 절약
저장된 데이터 공동 이용, 데이터 표준화, 통합 관리, 최신성, 실시간 처리 가능
데이터의 일관성/무결성, 보안 유지
단점
DB 전문가 부족
전산화 비용 증가
과부하(오버헤드) 발생 가능
백업, 리커버리 어려움
시스템 복잡
- 스키마
DB 구조, 제약 조건에 관한 명세를 기술한 메타데이터의 집합
속성, 개체, 관계, 제약조건 등

분류
외부 스키마
사용자, 개발자가 필요로하는 DB 구조
개념 스키마
DB 전체적인 논리적 구조
모든 응용 프로그램 등이 필요로 하는 데이터를 종합한 조직 전체의 DB → 하나만 존재
내부 스키마
물리적 저장장치 입장에서 본 DB 구조
실제로 DB에 저장될 레코드의 형식 정의, 저장 데이터의 표현 방법, 내부 레코드의 물리적 순서 등
schema

- 절차형 SQL의 테스트와 디버깅
디버깅으로 기능의 적합성 여부를 검증, 실행을 통해 결과를 확인하는 테스트 과정
목적: 테스트를 통해 오류를 발견한 후 디버깅을 통해 오류 발생 소스 코드를 추적하며 수정
2. 통합 구현
1) 단위 모듈(Unit Module)
SW 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것

단위 기능: 단위 모듈로 구현되는 하나의 기능
사용자, 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 함
두 개의 단위모듈을 합쳐서 두 개의 기능 구현 가능
구성요소: 처리문, 명령문, 데이터 구조 등
독립적인 컴파일, 다른 모듈에 호출/삽입 가능
단위기능 명세서 작성 후 입출력 기능과 알고리즘 구현
2) IPC
Inter-Process Communication

모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현 가능

- 대표 메소드
Shared Memory
다수 프로세스가 공유 메모리로 통신
Socket
네트워크 소켓
Semaphores
공유 자원에 대한 접근 제어를 통해 통신
Pipes & Named Pipes
파이프(선입선출)라는 메모리를 공유하며 통신, 프로세스 간 파이프 동시 접근 불가
Message Queueing
메시지가 발생하면 이를 전달하며 통신
3) 단위 모듈 테스트
단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지
Unit Test

화이트박스 테스트, 블랙박스 테스트 기법 사용
모듈 단독 실행 환경과 데이터가 필요
기능 단위 디버깅 용이 / 시스템 수준의 오류는 못 잡음
4) 테스트 케이스
입력값, 실행조건, 기대결과 등의 항목에 대한 명세서

- 구성요소 (ISO/IEC/IEEE 29119-3 표준)
식별자
테스트 항목: 테스트 대상(모듈, 기능)
입력 명세: 입력값, 조건
출력 명세
환경 설정: 필요한 HW, SW
특수 절차 요구
의존성 기술
5) 통합 개발 환경(IDE)
코딩, 디버그, 컴파일, 배포 등을 제공하는 SW 개발환경

6) 빌드 도구
소스 코드 → 제품 소프트웨어

전처리, 컴파일 등

Ant: 아파치, 자바 공식 빌드 도구

Maven: 아파치, ant 대안

Gradle: ant, maven 보완

3. 소프트웨어 패키징
1) 소프트웨어 패키징
모듈별로 생성한 실행 파일을 묶어 배포용 설치 파일 만들기

사용자 중심 진행
소스코드는 모듈화하여 패키징
- 고려사항
사용자 시스템 환경 정의 (OS, CPU, 메모리 등)
UI는 시각적인 자료와 함께 제공
하드웨어와 함께 관리되도록 Managed Service 형태로 제공
내부 콘텐츠 암호화 및 보안
다른 콘텐츠 및 단말기간 DRM 연동 고려
사용자 편의성을 위한 복잡성 및 비효율성 문제 고려
소프트웨어 종류에 적합한 암호화 알고리즘 적용
2) 릴리즈 노트
개발 과정의 릴리즈 정보를 최종 사용자와 공유하는 문서

테스트 진행 방법, 결과, 소프트웨어 사양 확인 가능
전체 기능, 서비스 내용, 개선 사항 공유
버전 관리, 릴리즈 정보 관리 가능
초기 배포 및 출시 후 추가 배포 시에 제공
- 초기 버전 작성 시 고려사항
현재 시제로 작성
신규 소스, 빌드, 변경/개선된 이력 작성
머릿말, 개요, 목적, 문제 요약, 재현 항목, 수정/개선 내용, 사용자 영향도, SW 지원 영향도, 노트, 면책 조항, 연락처
3) 디지털 저작권 관리(DRM)
원본 콘텐츠가 아날로그인 경우, 디지털로 변환 후 패키저로 DRM 패키징
콘텐츠 크기가 작은 경우(음원, 문서) 요청 시점에 실시간 패키징, 큰 경우 패키징 후 배포
패키징 수행 시 암호화된 저작권자의 전자서명 포함, 라이선스 정보가 클리어링 하우스에 등록됨
콘텐츠 사용 시 클리어링 하우스에 등록된 라이선스 정보로 사용자 인증, 권한 여부 확인 필요
종량제 방식, 클리어링 하우스로 실제 사용량 측정 후 요금 부과
- DRM 구성 요소
클리어링 하우스
저작권 사용 권한, 라이선스, 암호화된 키, 사용량에 따른 결제 관리 수행
콘텐츠 제공자: 저작권자
패키저
콘텐츠를 메타데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
콘텐츠 분배자
암호화된 콘텐츠를 유통하는
콘텐츠 소비자
DRM 컨트롤러
배포된 콘텐츠의 이용권한 통제 프로그램
보안 컨테이너
콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
- DRM 기술 요소
암호화 (+전자 서명)
키 관리
암호화 파일 생성(Packager)
식별 기술
저작권 표현
정책 관리
크랙 방지
인증
4) 소프트웨어 매뉴얼
- 설치 매뉴얼
사용자 기준 작성
설치 a-z 빠짐없이 순서대로 작성
오류 메시지, 예외 상황 별도 분류 설명
목차/개요, 서문, 기본 사항 포함
기능 식별 → UI 분류 → 설치/백업 파일 → Uninstall 절차 확인 → 이상 케이스 확인 → 최종 매뉴얼 적용
> 기본 사항
소프트웨어 개요
주요 기능 및 UI, 그림으로 설명
설치 관련 파일
설치에 필요한 파일, exe, ini, log 등 파일 설명
설치 아이콘
프로그램 삭제
관련 추가 정보
- 사용자 매뉴얼
사용 과정에서 필요한 내용에 대한 문서

오류 패치, 기능 업그레이드 등을 위해 매뉴얼 버전 관리
개별 동작 가능한 컴포넌트 단위로작성
컴포넌트 명세서, 구현 설계서 토대로 작성
목차/개요, 서문, 기본사항 등 포함
작성 지침 정의 → 사용자 매뉴얼 구성 요소 정의 → 구성 요소별 내용 작성 → 사용자 매뉴얼 검토
5) 형상 관리
Git, CVS, Subversion 등

- 중요성
SW 변경사항 추적, 통제
무절제한 변경 방지
버그, 수정사항 추적
진행 정도 확인 기준으로 사용 가능
배포본 관리 효율
여러 개발자 동시 개발 가능
- 기능
형상 식별
형상관리 대상에 이름, 관리번호를 부여하고 계층(Tree) 구조로 구분 → 수정, 추적 용이하도록
버전 제어
다른 버전의 형상 항목 관리
형상 통제(변경 관리)
변경 요구 검토
형상 감사
형상 기록(상태 보고)
- 소프트웨어 버전 등록 관련 주요 기능
저장소(Repository): 최신 버전 파일, 변경 정보 저장소
가져오기: 빈 저장소에 파일 복사
체크아웃: 저장소에서 파일 받아옴
체크인: 소스 수정 후 저장소 갱신
커밋: 충돌을 알리고 수정 후 갱신 완료
동기화
- 방식에 따른 분류
> 공유 폴더 방식
버전 관리 자료를 로컬 컴퓨터의 공유폴더에 저장
SCSS, RCS, PVCS, QVCS

> 클라이언트/서버 방식
중앙시스템(서버)에 저장
CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce

> 분산 저장소 방식
하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장

개발자가 로컬 저장소에서 우선 반영(버전 관리)한 뒤, 이걸 다시 원격 저장소에 반영
원격 저장소에 문제가 생겨도 로컬 저장소 자료로 작업 가능
Git, GNU arch, DCVS, Bazaar, Mecurial, TeamWare, BitKepper, Plastic SCM

- 대표적 기술
> Subversion(SVN)
CVS 개선, 아파치

클라이언트/서버 구조, 서버에는 최신 파일
서버 자료를 클라이언트로 복사해서 작업 후 변경 내용을 서버에 반영
모든 개발 작업은 trunk 디렉토리에서 수행
추가 개발 작업은 branches 디렉토리 안에 별도의 디렉토리를 만들어 작업을 완료 후 trunk에 머지
커밋 시 리비전 1씩 증가
서버는 주로 유닉스, 클라이언트는 상관 없음
오픈 소스, 무료
CVS의 단점이었던 파일, 디렉토리명 변경, 이동 등이 가능
> Git
리누스 토발즈

분산 버전 관리 시스템. 로컬/원격 저장소
지역 저장소: 개발자들이 실제 개발을 진행, 버전관리 수행
원격 저장소: 협업을 위해 버전 공동 관리, 내 작업 반영하거나 다른 개발자의 작업 가져오기
버전 관리가 로컬에서 진행되므로 버전관리 신속, 원격/네트워크 문제 시 작업 가능
브랜치를 이용하면 기존 코드에 영향 없이 다양한 테스팅 가능
스냅샷: 파일의 변화 → 이전 스냅샷의 포인터를 가지므로 버전 흐름 파악 가능
6) 빌드 자동화 도구
소스 코드를 컴파일한 후 여러개의 모듈을 묶어 실행 파일로 만드는 과정
→ 빌드, 테스트, 배포를 자동화 하는 도구

지속적인 통합 개발환경
한 작업 마무리 시 모듈 단위로 개발된 코드를 지속적으로 통합
빌드 자동화 도구 유용
Ant, Make, Maven, Gradle, Jenkins

- Jenkins
자바 기반 오픈소스

서블릿 컨테이너에서 실행되는 서버 기반 도구
형상관리 도구와 연동 가능, Web UI 제공
분산 빌드, 테스트 가능
- Gradle
Groovy 기반 오픈소스

Groovy로 만든 DSL(Domain Specific Language)를 스크립트 언어로 사용
실행 명령을 모아 태스크로 만든 후, 태스크 단위로 실행
빌드 캐시: 태스크 재사용 / 다른 시스템의 태스크 공유
4. 애플리케이션 테스트
1) 애플리케이션 테스트
잠재 결함을 찾아내는 일련의 행위
→ 요구사항 만족 여부 확인, 기능 수행 검증 (명세서에 맞는지)

2) 테스트 관련 용어
결함 집중(Defect Clustering): 대부분의 결함이 소수의 특정 모듈에 집중해서 발생
파레토 법칙: 80%의 오류는 20% 모듈에서 발견 → 20% 모듈을 집중적으로 테스트하자
살충제 패러독스: 살충제 내성
오류 부재의 궤변: 결함이 없어도 요구사항 불만족 시 품질이 낮은 것
3) 실행 여부에 따른 분류
정적 테스트
프로그램 실행 없이 명세서, 소스 코드를 대상으로
개발 초기 결함 발견 가능 → 비용 ↓
ex) 워크스루, 인스펙션, 코드 검사
동적 테스트
실행해서 하는 테스트
소프트웨어 개발 모든 단계에서 수행 가능
ex) 블랙박스, 화이트박스
4) 테스트 기반에 따른 분류
명세 기반 테스트: 명세 빠진 것 없는지
ex) 동등 분할, 경계 값 분석
구조 기반 테스트: SW 내부 논리 흐름에 따라 테스트 케이스 작성 후 확인
ex) 구문/결정/조건 기반
경험 기반 테스트: 테스터의 경험 기반, 명세/시간이 충분하지 않을 때
ex) 에러 추정, 체크리스트, 탐색적 테스팅
5) 시각에 따른 분류
검증 테스트
개발자의 시각에서, 명세서 일치 여부
확인 테스트
사용자의 시각에서, 요구한대로 완성됐는지
6) 목적에 따른 분류
회복 테스트: 시스템에 결함을 주어 실패 유도 → 올바르게 복구되는지
안전 테스트: 시스템 보호 도구가 침입에 대응을 잘 하는지
강도 테스트: 과부하 확인
성능 테스트
구조 테스트: SW 내부 논리, 소스 코드의 복잡도
회귀 테스트: 변경/수정 사항의 결함
병행 테스트: 변경된 SW와 기존 SW에 동일한 인풋 → 결과 비교
7) 화이트박스 테스트
원시 코드의 논리적인 경로로 테스트 케이스 설계

모듈 내부 작동 관찰
원시 코드(모듈)의 모든 문장을 한 번 이상 실행
프로그램 제어 구조에 따라 선택, 반복 등 분기점 부분을 수행 → 논리적 경로 제어
- 종류
기초 경로 검사
가장 대표적
설계자가 논리적 복잡성 측정할 수 있게 해줌
결과는 실행 경로의 기초를 정의하는 지침으로 사용
제어 구조 검사
조건 검사: 논리적 조건
루프 검사: 반복 구조
데이터 흐름 검사: 변수
- 검증 기준
문장 검증 기준: 모든 구문이 한 번 이상 수행되도록
분기 검증 기준: 결정 검증 기준, 모든 조건문 true/false
조건 검증 기준: 조건문에 포함된 개별 조건식의 결과 true/false
분기/조건 기준: 분기 + 조건
8) 블랙박스 테스트
각 기능의 완전한 작동을 입증, 기능 테스트

프로그램 구조 고려 X → 테스트 케이스는 모듈 요구나 명세를 기초로 결정
소프트웨어 인터페이스에서 실시
부정확/누락된 기능, 인터페이스 오류, 자료 구조나 외부 DB 접근에 따른 오류, 행위/성능 오류, 초기화 종료 오류 등을 발견하기 위해 사용
테스트 과정의 후반부
- 종류
동치 분할 검사
동치 클래스 분해, 동등 분할 기법
입력 자료에 초점을 맞춰 테스트 케이스를 만들어 검사
타당한 입력, 타당하지 않은 입력 자료의 개수를 균등하게 배분
경계값 분석
입력자료에만 치중한 동치 분할 기법을 보완
입력 조건의 중간값보다 경계값에서 오류가 발생할 확률이 높음 → 경계값을 테스트 케이스로 선정
원인-효과 그래프 검사
입출력 상황 분석 → 효용성이 높은 테스트케이스를 선정하여 검사
오류 예측 검사
과거의 경험이나 확인자의 감각으로 테스트
보충적 검사 기법
데이터 확인 검사
비교 검사
여러 버전의 프로그램에 동일한 테스트 자료를 제공 → 동일 결과 출력되는지
9) 개발 단계에 따른 애플리케이션 테스트
app_test

- 단위 테스트(Unit Test)
코딩 직후 모듈, 컴포넌트 초점 테스트

인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 검사
사용자의 요구사항을 기반으로 한 기능성 테스트를 우선적으로
(주로)구조 기반 테스트 cf) 명세 기반 테스트
발견 가능한 오류: 알고리즘 오류, 탈출구 없는 반복문, 틀린 수식
- 통합 테스트(Integration Test)
단위 테스트가 완료된 모듈을 결합, 하나의 시스템으로 완성시키는 테스트

비점진적 통합 방식
단계적 통합 절차 없이 모두 결합된 프로그램 전체를 테스트
빅뱅 통합 테스트 방식
소규모 SW, 단시간
오류 발견 및 장애 위치 파악, 수정이 어려움
점진적 통합 방식
모듈 단위로 단계적으로 통합하면서 테스트
하향식, 상향식, 혼합식
오류 수정 용이, 인터페이스 연관 오류 테스트 가능성 높음
> 하향식 통합 테스트
상위 모듈에서 하위 모듈로 통합

깊이 우선 통합법, 넓이 우선 통합법
테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있다
상위 모듈에서 테스트 케이스 사용하기 어려움
> 상향식 통합 테스트
하위 → 상위 모듈

스텁은 필요하지 않지만, 한 주요 제어모듈과 관련된 종속 모듈의 그룹인 클러스터가 필요
> 테스트 드라이버와 테스트 스텁
드라이버
하위 모듈 호출 도구 / 매개 변수를 전달하고 테스트 결과 도출
상위 모듈 없이 하위 모듈이 있는 경우
상향식 테스트
스텁
제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행 / 일시적 조건만 가지는 테스트용 모듈
상위 모듈은 있는데 하위 모듈이 없는 경우
하향식 테스트
공통점과 차이점
공통점: 소프트웨어 개발, 테스트 병행 시 이용
차이점
드라이버
존재하는 하위 모듈과 존재하지 않는 상위 모듈 간의 인터페이스 역할
개발 완료 시 드라이버는 본래 모듈로 교체
스텁
가짜 모듈, 임시 모듈
시험용 모듈이기 때문에 드라이버보다 작성 쉬움
- 시스템 테스트
개발된 SW가 해당 컴퓨터에서 완벽히 수행되는가

실제 사용 환경과 유사한 환경 만들어야 함
기능적/비기능적 요구사항을 모두 만족하는지
- 인수 테스트
사용자의 요구사항 충족 여부

사용자가 직접 테스트

문제가 없으면 사용자는 SW를 인수 → 프로젝트 종료

알파 테스트: 개발자 앞에서, 통제된 환경, 오류/문제점을 사용자와 개발자가 함께 확인

베타 테스트: 선정된 유저가 여러 사용자 앞에서. 필드 테스팅. 제어되지 않은 환경

10) 회귀 테스팅
테스트된 프로그램의 테스팅을 반복
통합 테스트로 인해 변경된 모듈이나 컴포넌트의 새로운 오류를 확인

수정 부분 때문에 새로운 오류를 발생하지 않음을 보증하기 위해
변경 부분을 테스트할 수 있는 케이스만 선정하여 수행
11) 애플리케이션 테스트 프로세스
순서

테스트 계획: 명세서 등을 기반으로 테스트 목표, 대상, 범위 결정
테스트 분석 및 디자인
테스트 케이스 및 시나리오 작성
테스트 수행
테스트 결과 평가 및 리포팅
결함 추적 관리
12) 테스트 케이스
요구사항 준수 여부 확인을 위해 설계된 테스트 항목 명세서
입력값, 실행 조건, 기대 결과
→ 명세 기반 테스트의 설계 산출물

테스트 오류 방지, 인력/시간 ↓
테스트 목표, 방법 설정 후 작성
시스템 설계 단계에서 작성하는 것이 이상적
- 테스트 시나리오
테스트 케이스 적용 순서에 따라 묶음 집합
테스트 케이스를 적용하는 구체적인 절차 명세
→ 절차, 조건, 입력 데이터 등

- 테스트 오라클
테스트 결과가 올바른지 판단하기 위해 정의된 참 값을 대입하여 비교

> 종류
참 오라클: 모든 테스트 케이스의 기대값 제공, 발생된 모든 오류 검출 가능
샘플링 오라클: 특정한 몇몇 케이스만
추정 오라클: 샘플링 오라클 개선, 몇 개는 결과 제공, 나머지는 추정
일관성 검사 오라클: 앱 변동 시 전후 결과값 동일한지 확인
13) 테스트 자동화 도구
사람이 하던 걸 스크립트 형태의 자동화 도구 시킴

- 유형
정적 분석 도구: 프로그램 실행 X, 소스 코드의 코딩 표준, 스타일, 복잡도 등을 발견
테스트 케이스 생성 도구
자료 흐름도: 자료 원시 프로그램 입력 → 파싱 → 자료 흐름도 작성
기능 테스트: 기능 구동의 모든 가능한 상태를 파악하여 입력 작성
입력 도메인 분석: 코드 내부 말고 입력 변수 도메인 분석해서 테스트 데이터 만듦
랜덤 테스트: 입력 값 무작위 추출
테스트 실행 도구: 데이터/수행방법 등이 포함된 스크립트
데이터 주도 접근 방식: 스프레드 시트에 데이터 저장
키워드 주도 접근 방식: 스프레드 시트에 동작 키워드와 테스트 데이터 저장
성능 테스트 도구
테스트 통제 도구
테스트 계획, 관리, 수행, 결함 관리 도구
ex) 형상 관리 도구, 결함/추적 관리 도구
테스트 하네스 도구
컴포넌트, 모듈 테스트 환경의 한 부분 → 테스트를 위한 코드, 데이터
테스트 실행 환경 시뮬레이션 후 테스트
- 테스트 하네스의 구성 요소
테스트 드라이버: 하위 모듈 호출, 매개변수 전달, 결과 도출
테스트 스텁: 제어 모듈이 호출하는 타 모듈의 기능만 단순히 수행, 일시적으로 필요한 조건만 충족
테스트 슈트: 테스트 케이스의 집합
테스트 케이스: 입력값, 조건, 기대값
테스트 스크립트: 자동화된 테스트 실행 절차에 대한 명세서
목 오브젝트: 조건 입력하면 그 상황에 맞는 행위 수행
14) 결함
오류, 작동 실패 등 이상 동작
→ 기대값/결과 간 차이나 업무 내용과의 불일치도 모두 결함에 해당

15) 애플리케이션 성능 분석
요구한 기능을 최소한의 자원으로 최대한 많이, 신속하게 처리하는 정도

- 성능 측정 지표
처리량
응답 시간: 요청~응답
경과 시간: 작업 의뢰~처리 완료
자원 사용률
- 빅 오 표기법(Big-O Notation)
알고리즘 실행시간 최악일 때를 표기하는 방법
cf) 오메가 표기법(신뢰성 ↓), 세타 표기법(평가 까다로움)

O(1)
입력값(n)에 독립적으로 문제 해결에 하나의 단계만 거침
스택의 삽입(push), 삭제(pop)
O(log n)
필요 단계가 입력값, 조건에 의해 감소
이진트리, 이진 검색
O(n)
입력값과 1:1 관계
for문
O(n log n)
nlogn번만큼 수행
힙정렬, 합병 정렬
O(n^2)
삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬
O(2^n)
피보나치 수열
- 순환 복잡도
한 프로그램의 논리적 복잡도 측정
맥케이브 순환도, 맥케이브 복잡도 메트릭

프로그램의 경로의 수 정의 → 모든 경로가 한 번 이상 수행됨을 보장하기 위해 테스트 횟수 상한선
> 순환 복잡도 계산
제어 흐름도 G에서 순환 복잡도 V(G) 계산

순환 복잡도는 제어흐름도의 영역 수와 일치하므로 영역 수를 계산
V(G) = E - N + 2
E == 화살표 수
N == 노드 수
16) 소스 코드 최적화
클린 코드
단순 명료한 코드, 잘 작성된 코드
나쁜 코드(Bad Code)
로직이 복잡하고 이해하기 어려운 코드
스파게티 코드: 코드 로직이 서로 복잡하게 얽혀있는 코드
외계인 코드: 너무 오래되거나 참고할 게 없어서 유지보수 어려운 코드
- 클린 코드 작성 원칙
가독성
단순성: 한 번에 한 가지 처리하도록, 클래스/메소드 등을 최소 단위로 분리
의존성 배제: 코드가 다른 모듈에 미치는 영향을 최소화, 변경 시 다른 부분에 영향이 없도록 작성
중복성 최소화
추상화: 상위 클래스/메소드/함수에서는 간략히 애플리케이션의 특성을 나타내고, 상세 내용은 하위에서 구현
17) 소스 코드 품질 분석 도구
정적 분석 도구
실행 X. 코딩 표준이나 스타일, 결함 확인
애플리케이션 초기 결함 찾기 → 완료 시점에서는 품질 검증 차원
자료 흐름, 논리 흐름을 분석 → 비정상적 패턴 찾기
코딩의 복잡도, 모델 의존성, 불일치성 분석
pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura
동적 분석 도구
실행하여 메모리 누수, 스레드 결함 분석
Avalanche, Valgrind
4. 인터페이스
1) EAI
Enterprise Application Integration

기업 내 앱/플랫폼 간 정보 연동 솔루션
비즈니스 간 통합, 연계성 증대 → 효율성, 확정성 ↑

- 구축 유형
Point-to-point: 애플리케이션 1:1 연결 / 변경, 재사용 어려움
Hub & Spoke: 중앙 집중형(허브 시스템) / 확장, 유지보수 용이 / 허브 시스템 장애 시 시스템 전체에 영향
Message Bus(ESB 방식): 앱 사이에 미들웨어 / 확장성 ↑, 대용량 처리 가능
Hybrid: Hub&Spoke + Message Bus
그룹 내에서는 허브 시스템, 그룹 간에는 메시지 버스
필요한 경우 한 가지 방식으로 EAI 구현 가능
데이터 병목 최소화
- ESB
Enterprise Service Bus

애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션

애플리케이션 통합 측면에선 EAI와 유사, 그러나 서비스 중심 통합 지향
애플리케이션과 Loose Coupling 유지 → 범용성을 위해
관리, 보안 유지 쉬움, 높은 품질 지원 가능
2) JSON
JavaScript Object Notation

속성-값 쌍, ajax에서 xml 대체

3) XML
eXtensible Markup Language
다목적 마크업 언어

HTML이 웹 브라우저에서 상호 호환적이지 못함
SGML의 복잡성 해결

4) AJAX
Asynchronous JavaScript and XML
비동기 통신 기술
클라이언트-서버 간 XML 데이터를 교환 → 웹 페이지와 자유롭게 상호작용

5) 인터페이스 보안 기능 적용
일반적으로 네트워크, 애플리케이션, 데이터베이스 영역에 적용

네트워크 영역
인터페이스 송/수신 간 스니핑으로 데이터 탈취 및 변조 위협 때문에 네트워크 트래픽 암호화
IPSec, SSL, S-HTTP 등
IPSec: IP Security. IP 패킷 단위의 데이터 보안 프로토콜, 양방향 암호화 지원
애플리케이션 영역
코드 상 보안 취약점 보완
데이터 베이스 영역
DB, 스키마, 엔티티 접근 권한 및 프로시저, 트리거 등
6) 데이터 무결성 검사 도구
시스템 파일 변경 시 관리자에게 알려줌
인터페이스 보안 취약점 분석에 사용

백도어 만들거나 시스템 파일에서 발자국 지우는 행위 감지
해시 함수로 현재 파일/디렉토리 상태 DB 저장 후 상태 변경 시 알려줌

Tripwire, AIDE, Samhain, Claymore, Slipwire, Fcheck

7) 인터페이스 구현 검증 도구
xUnit
테스트 코드 반복 줄여주고, 자동화된 예상 결과 제공 → 단위 테스트 프레임워크
JUnit, CppUnit, NUnit, HttpUnit 등
STAF
서비스 호출, 컴포넌트 재사용 등 다양한 환경 지원
크로스 플랫폼, 분산 소프트웨어 테스트 환경 지원
분산의 경우, 데몬이 테스트 응답 대신, 테스트 완료 시 통합/자동화하여 프로그램 완성
FitNesse
웹 기반 테스트 케이스 설계, 실행, 결과 확인 지원
NTAF
FitNesse의 협업 기능 + STAF의 재사용성, 확장성
네이버의 테스트 자동화 프레임워크
Selenium
다양한 브라우저, 개발 언어 지원 → 웹 앱 테스트 프레임워크
watir: Ruby
8) APM
Application Performance Management/Monitoring

성능 관리를 위해 접속자, 자원 현황, 트랜잭션 수행 내역, 장애 진단 등 다양한 모니터링 도구

리소스 방식: Nagios, Zabbix, Cacti
엔드투엔드 방식: VisualVM, 제니퍼, 스카우터